---
title: "Introduction"
author: "Mathieu Carmassi"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The package `calibrationCode` is a package that run a Bayesian calibration of a numerical code. This code can be a "black box" as much as an anlytical function. To use properly the package, the function has to be defined with a certain form. We go into the details in section Prerequisite. Then, a statistical model has to be selected before runing the calibration.

## Prerequisites

The "black box" or the function have to be defined in some way. Initially, if the code inputs contain some controlled variables and parameters, the way to create the function is:
$$Y=f(\boldsymbol{X},\boldsymbol{\theta)} $$
where $Y$ is the output of the function, $\boldsymbol{X}$ stands for the controlled variables matrix and $\boldsymbol{\theta}$ for the parameter vector. All along this vignette an example of a toy function illustrates how to set up properly a study using the `calibrationCode` package.

Let us consider the harmonic response of a spring which has a mass $m$ and a spring constant $k$. Let us say that we have observed, during 2 seconds, the harmonic displacement of a spring and we want to find to calibrate $m$ and $k$ according to the recorded values. The corresponding equation is:
$$ x(t,\{m,k\})=sin\Bigg(t,\sqrt{\frac{k}{m}}\Bigg)-cos\Bigg(t,\sqrt{\frac{k}{m}}\Bigg) $$
where $t$ corresponds to the time in seconds.

```{r, echo=TRUE}
library(ggplot2)
x <- seq(0,1,length.out = 200)
code <- function(x,theta)
{
  return(sin(x*sqrt(theta[1]/theta[2]))-cos(x*sqrt((theta[1]/theta[2]))))
}
```


```{r, echo=FALSE,fig.width=7,fig.align='center'}
ggdata <- data.frame(x=x,y=code(x,c(1.5,9e-3))+rnorm(200,0,0.05))
p <- ggplot(ggdata,aes(x=x,y=y))+geom_line()+theme_light()+ggtitle('Observation of the displacement')
p
```

The code gives an output slightly differement from experimental data

```{r, echo=FALSE,fig.width=7,fig.align='center'}
ggdata <- data.frame(x=x,y=code(x,c(1.7,9e-3))+rnorm(200,0,0.05),type='experiments')
ggdata2 <- data.frame(x=x,y=code(x,c(2,1e-2)),type='code output')
ggdata <- rbind(ggdata,ggdata2)
p <- ggplot(ggdata,aes(x=x,y=y,color=type))+geom_line()+theme_light()+theme(legend.position=c(0.80,0.80),
                              legend.title=element_blank())
p
```

The code has been run with theoretical value of $\boldsymbol{\theta}$ which are $m=10gr$ and $k=2$. The aim of `calibrationCode` is to retrieve the "good values" of $\boldsymbol{\theta}$ which corresponds to the experiments from prior distributions on $\boldsymbol{\theta}$ and from collected data.

## Define a statistical model
`calibrationCode` allows the user to elect several statistical models. For more details on the implemented models, the user is referred to [1].

The first model available is:
$$\mathcal{M}_1:\forall i \in [1,\dots,n] \ Y_{exp_i}=f(\boldsymbol{x_i},\boldsymbol{\theta})+\epsilon_i$$
where $Y_{exp_i}$ stands for the $i^{th}$ from $n$ observations, $\boldsymbol{x_i}$ for the vector of controlled variables corresponding, and $\epsilon_i$ for the measurement error. In `calibrationCode`, $\epsilon$ will always be defined as a white Gaussian noise with $\epsilon \overset{iid}{\sim}\mathcal{N}(0,\sigma_{err}^2)$. $\sigma_{err}^2$ stands for the variance of the measurement error and has to be found as much as $\boldsymbol{\theta}$.


The second model intervienes when the code is too long to run. In that case:
$$\mathcal{M}_2:\forall i \in [1,\dots,n] \ Y_{exp_i}=\boldsymbol{F}(\boldsymbol{x_i},\boldsymbol{\theta})+\epsilon_i$$
where $\boldsymbol{F}(\{\bullet,\bullet\})\sim\mathcal{PG}(m(\{\bullet,\bullet\}),c(\{\bullet,\bullet\},\{\bullet,\bullet\}))$ is a Gaussian process defined for an expectancy $m$ and covariance $c$ functions.

The third model lie on $\mathcal{M}_1$ in the way that we consider another error term called discrepancy.
$$\mathcal{M}_3:\forall i \in [1,\dots,n] \ Y_{exp_i}=f(\boldsymbol{x_i},\boldsymbol{\theta})+\delta(\boldsymbol{x_i})+\epsilon_i$$
where $\delta(\boldsymbol{x_i})\sim\mathcal{PG}(m(\bullet),c(\bullet,\bullet))$ is a Gaussian process qunatifying the code error. In `calibrationCode`,



## Define the prior distributions

## Run the Bayesian calibration

## Conclusion
<div class="align-justify">
The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:
</div>

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
