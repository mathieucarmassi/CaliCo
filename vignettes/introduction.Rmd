---
title: "Introduction"
author: "Mathieu Carmassi"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


The package `calibrationCode` is a package that run a Bayesian calibration of a numerical code. This code can be a "black box" as much as an anlytical function. To use properly the package, the function has to be defined with a certain form. We go into the details in section Prerequisite. Then, a statistical model has to be selected before runing the calibration.

## Prerequisites

The "black box" or the function have to be defined in some way. Initially, if the code inputs contain some controlled variables and parameters, the way to create the function is:
$$Y=f(\boldsymbol{X},\boldsymbol{\theta)} $$
where $Y$ is the output of the function, $\boldsymbol{X}$ stands for the controlled variables matrix and $\boldsymbol{\theta}$ for the parameter vector. All along this vignette an example of a toy function illustrates how to set up properly a study using the `calibrationCode` package.

Let us consider the harmonic response of a spring which has a mass $m$ and a spring constant $k$. Let us say that we have observed, during 2 seconds, the harmonic displacement of a spring and we want to find to calibrate $m$ and $k$ according to the recorded values. The corresponding equation is:
$$ x(t,\{m,k\})=sin\Bigg(t,\sqrt{\frac{k}{m}}\Bigg)-cos\Bigg(t,\sqrt{\frac{k}{m}}\Bigg) $$
where $t$ corresponds to the time in seconds.

```{r,cache=TRUE,echo=TRUE}
x <- seq(0,1,length.out = 200)
code <- function(x,theta)
{
  return(sin(x*sqrt(theta[1]/theta[2]))-cos(x*sqrt((theta[1]/theta[2]))))
}
```


```{r, echo=FALSE,fig.width=7,fig.align='center'}
library(ggplot2)
ggdata <- data.frame(x=x,y=code(x,c(1.5,9e-3))+rnorm(200,0,0.05))
p <- ggplot(ggdata,aes(x=x,y=y))+geom_line()+theme_light()+ggtitle('Observation of the displacement')
p
```

The code gives an output slightly differement from experimental data

```{r, echo=FALSE,fig.width=7,fig.align='center'}
ggdata <- data.frame(x=x,y=code(x,c(1.7,9e-3))+rnorm(200,0,0.04),type='experiments')
ggdata2 <- data.frame(x=x,y=code(x,c(2,1e-2)),type='code output')
ggdata <- rbind(ggdata,ggdata2)
p <- ggplot(ggdata,aes(x=x,y=y,color=type))+geom_line()+theme_light()+theme(legend.position=c(0.80,0.80),
                              legend.title=element_blank())
p
```

The code has been run with theoretical value of $\boldsymbol{\theta}$ which are $m=10gr$ and $k=2$. The aim of `calibrationCode` is to retrieve the "good values" of $\boldsymbol{\theta}$ which corresponds to the experiments from prior distributions on $\boldsymbol{\theta}$ and from collected data.

## Define a statistical model

### Definition of the models

`calibrationCode` allows the user to elect several statistical models. For more details on the implemented models, the user is referred to [1].

The first model available is:
$$\mathcal{M}_1:\forall i \in [1,\dots,n] \ Y_{exp_i}=f(\boldsymbol{x_i},\boldsymbol{\theta})+\epsilon_i$$
where $Y_{exp_i}$ stands for the $i^{th}$ from $n$ observations, $\boldsymbol{x_i}$ for the vector of controlled variables corresponding, and $\epsilon_i$ for the measurement error. In `calibrationCode`, $\epsilon$ will always be defined as a white Gaussian noise with $\epsilon \overset{iid}{\sim}\mathcal{N}(0,\sigma_{err}^2)$. $\sigma_{err}^2$ stands for the variance of the measurement error and has to be found as much as $\boldsymbol{\theta}$.


The second model intervienes when the code is too long to run. In that case:
$$\mathcal{M}_2:\forall i \in [1,\dots,n] \ Y_{exp_i}=\boldsymbol{F}(\boldsymbol{x_i},\boldsymbol{\theta})+\epsilon_i$$
where $\boldsymbol{F}(\{\bullet,\bullet\})\sim\mathcal{PG}(m(\{\bullet,\bullet\}),c(\{\bullet,\bullet\},\{\bullet,\bullet\}))$ is a Gaussian process defined for an expectancy $m$ and covariance $c$ functions.

The third model lie on $\mathcal{M}_1$ in the way that we consider another error term called discrepancy.
$$\mathcal{M}_3:\forall i \in [1,\dots,n] \ Y_{exp_i}=f(\boldsymbol{x_i},\boldsymbol{\theta})+\delta(\boldsymbol{x_i})+\epsilon_i$$
where $\delta(\boldsymbol{x_i})\sim\mathcal{PG}(m(\bullet),c(\bullet,\bullet))$ is a Gaussian process qunatifying the code error.

*In `calibrationCode` $m(\bullet)$ in discrepancy is set to zero for now*.

Similarly, the fourth model is defined from $\mathcal{M}_2$ by adding the discrepancy:
$$\mathcal{M}_4:\forall i \in [1,\dots,n] \ Y_{exp_i}=F(\boldsymbol{x_i},\boldsymbol{\theta})+\delta(\boldsymbol{x_i})+\epsilon_i$$

### Function model in `calibrationCode'

Define a model in `calibrationCode` is done through a function called `model` (the user is refered to `?models` for more details). It encompases, four main elements: the code, the $\boldsymbol{X}$, the experiments and the model selected. When the second or the fourth model is selected, an additional option `opt.emul` is needed. This option pilots the estimation of the Gaussian process used for the emulator.

*Note that `calibrationCode` uses the package `DiceKrigging` to run the estimation of the Gaussian process.*
```{r, echo=FALSE}
library(calibrationCode)
```                

```{r,cache=TRUE,echo=TRUE}
x <- seq(0,1,length.out = 200)
code <- function(x,theta)
{
  return(sin(x*sqrt(theta[1]/theta[2]))-cos(x*sqrt((theta[1]/theta[2]))))
}
Yexp <- code(x,c(1.7,9e-3))+rnorm(200,0,0.05)

md <- model(code,x,Yexp,model="model1")
```

### Withe the harmonic spring example

#### For the model 1
```{r,cache=TRUE, echo=TRUE}
x <- seq(0,1,length.out = 200)
code <- function(x,theta)
{
  return(sin(x*sqrt(theta[1]/theta[2]))-cos(x*sqrt((theta[1]/theta[2]))))
}
Yexp <- code(x,c(1.7,9e-3))+rnorm(200,0,0.04)

md1 <- model(code,x,Yexp,model="model1")
```

`md` is a `model.class` object, also a `R6Class` object, which contains some methods as `$plot` for example. The `$plot` takes two arguments which are $\boldsymbol{\theta}$ and $\sigma_{err}^2$. It allows the user to display the output of the code for such values at the same time as the experiments. The `$plot()` method return a `ggplot` object easy to manipulate.

```{r, echo=TRUE,fig.width=7,fig.align='center'}
p <- md1$plot(c(2,1e-2),0.05)
p + theme(legend.position=c(0.65,0.86),
                           legend.text=element_text(size = '10'),
                           legend.key=element_rect(colour=NA),
                           axis.text=element_text(size=10))
```

#### For the model 2
The estimation of the Gaussian process which emulates the function is done by `km` a `DiceKriging` function.

```{r,cache=TRUE, echo=TRUE}
opt.emul <- list(p=2,n.emul=200,type="matern3_2",binf=c(1.5,5e-3),bsup=c(2.5,2.5e-2),DOE=NULL)
md2 <- model(code,x,Yexp,model="model2",opt.emul = opt.emul)
```

```{r, echo=TRUE,fig.width=7,fig.align='center'}
p <- md2$plot(c(2,1e-2),0.05)
p + theme(legend.position=c(0.50,0.8),
                           legend.text=element_text(size = '10'),
                           legend.key=element_rect(colour=NA),
                           axis.text=element_text(size=10))
```

#### For the model 3

```{r,cache=TRUE, echo=TRUE}
md3 <- model(code,x,Yexp,model="model3",opt.disc=list(kernel.type="gauss"))
```

```{r, echo=TRUE,fig.width=7,fig.align='center'}
p <- md3$plot(c(2,1e-2),c(1,0.5),0.05)
p + theme(legend.position=c(0.65,0.86),
                           legend.text=element_text(size = '10'),
                           legend.key=element_rect(colour=NA),
                           axis.text=element_text(size=10))
```

#### For the model 4

```{r, echo=TRUE}
md4 <- model(code,x,Yexp,model="model4",opt.emul=opt.emul)
```

```{r, echo=FALSE,fig.width=7,fig.height=5,fig.align='center'}
p <- md4$plot(c(2,1e-2),c(1,0.5),0.05)
p + theme(legend.position=c(0.65,0.86),
                           legend.text=element_text(size = '10'),
                           legend.key=element_rect(colour=NA),
                           axis.text=element_text(size=10))
```

## Define the prior distributions

In Bayesian calibration a prior distribution is updated in a posterior distribution thanks to the likelihood. Define the prior distribution in `calibrationCode` is done as the following chunk.

```{r,fig.width=7,fig.align='center'}
gaussian <- prior(type.prior="gaussian",opt.prior=list(c(0.5,0.001)))
p <- gaussian$plot()
p
```

Where the prior function generates a `prior.class` which contains methods as `$plot()`. The arguments are `type.prior` and `opt.prior`. Identically as before the `$plot()` method returns a ggplot which can be stored into a variable and then modified by the user. To define sevaral prior densities, the rigth way is illustrated as the following

```{r,fig.width=7,fig.height=5,fig.align='center'}
priors <- prior(type.prior=c("gaussian","gamma"),opt.prior=list(c(0.5,0.001),c(5,1)))
grid.arrange(priors$Prior1$plot(),priors$Prior2$plot(),nrow=2)
```

The `grid.arrange` function allows to visualize both prior densities at the same time. The variable `priors` stores a list of the prior's number whished defined as a `prior.class` objects.

```{r,echo=TRUE}
priors$Prior1
priors$Prior2
```

## Run the Bayesian calibration
To run a Bayesian calibration



## Conclusion
