% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{calibrate}
\alias{calibrate}
\title{Generates \code{\link{calibrate.class}} objects}
\usage{
calibrate(md, pr, opt.estim, opt.valid = NULL, onlyCV = FALSE)
}
\arguments{
\item{md}{a \code{\link{model.class}} object}

\item{pr}{a \code{\link{prior.class}} object}

\item{opt.estim}{estimation options \itemize{\item{Ngibbs}{Number of iteration of the algorithm Metropolis within Gibbs}
\item{Nmh}{ Number of iteration of the Metropolis Hastings algorithm}
\item{thetaInit}{ Initial point}
\item{k}{ Tuning parameter for the covariance matrix sig}
\item{sig}{ Covariance matrix for the proposition distribution (\eqn{k*sig})}}}

\item{opt.valid}{list of cross validation options (default opt.valid=FALSE)\itemize{
\item{nCV}{ Number of iterations for the cross validation}
\item{type.valid}{ Type of cross validation selected. "loo" (leave one out) is the only method emplemented so far.}
}}

\item{onlyCV}{if TRUE run the cross validation only (default onlyCV=FALSE)}
}
\value{
\code{calibrate} returns a \code{\link{calibrate.class}} object. Two main methods are available:
\itemize{\item{$plot()}{ display the probability density of the prior with different options:}
\itemize{
\item {graph}{ The vector of the graph wanted. By default all the graph are displayed and graph=c("acf","chains","densities","output").
"acf" displays the correlation graph of the MCMC chains, "chains" plot the chains, "densities" shows the comparison of the
densities a priori and a posteriori, and "output" displays the output of the code with the calibrated one and its credibility
interval (if CI=TRUE).}
\item {separated}{ Allows to separate each graphs by displying one by one all the graphs. By default separated=FALSE}
\item {CI}{ Allows to add the posterior credibility interval to the output plot. By default CI=TRUE}
\item {select.X}{ When the number of X is >1, this option has to be activated to display the output plot. select.X
allows to choose one X for the x scale in the output plot}}
\item{$print()}{ return the main information concerning the estim.class object}}
}
\description{
\code{calibration} is a function that allows us to generate a \code{\link{calibrate.class}} class in which the estimation is
done from a \code{\link{model.class}} and a \code{\link{prior.class}} objects.
}
\examples{
###################### The code to calibrate
X <- cbind(seq(0,1,length.out=10),seq(0,1,length.out=10))
code <- function(X,theta)
{
  return((6*X[,1]*theta[2]-2)^2*theta[1]*sin(theta[3]*X[,2]-4))
}
Yexp <- code(X,c(1,1,11))+rnorm(10,0,0.1)

############### For the first model
###### Definition of the model
md <- model(code,X,Yexp,"model1")
###### Definition of the prior densities
pr <- prior(type.prior=c("gaussian","gaussian","gaussian","gamma"),opt.prior=
list(c(1,0.01),c(1,0.01),c(11,3),c(2,0.1)))
###### Definition of the calibration options
opt.estim=list(Ngibbs=2000,Nmh=6000,thetaInit=c(1,1,11,0.1),k=c(6e-3,1e-3,1e-5,1e-3),
sig=diag(4),Nchains=1,burnIn=3000)
###### Run the calibration
mdfit <- calibrate(md,pr,opt.estim)
####### The plot generated is a list of ggplot
p <- plot(mdfit,select.X=X[,1])
print(mdfit)
####### Run regular calibration plus cross validation (the plot function is available)
opt.valid <- list(type.valid='loo',nCV=10)
mdfitCV <- calibrate(md,pr,opt.estim,opt.valid)
print(mdfitCV)
####### Run cross validataion only (the plot function is disabled)
mdfitCV2 <- calibrate(md,pr,opt.estim,opt.valid,onlyCV=TRUE)
print(mdfitCV2)


############### For the second model
###### Definition of the model
### The lower and upper bound vector for the parameter
binf <- c(0.9,0.9,10.5)
bsup <- c(1.1,1.1,11.5)
opt.emul <- list(p=3,n.emul=50,type="matern5_2",binf=binf,bsup=bsup,DOE=NULL)
md2 <- model(code,X,Yexp,"model2",opt.emul)
###### Definition of the prior densities
pr <- prior(type.prior=c("gaussian","gaussian","gaussian","gamma"),opt.prior=
list(c(1,0.01),c(1,0.01),c(11,3),c(2,0.1)))
###### Definition of the calibration options
opt.estim=list(Ngibbs=2000,Nmh=6000,thetaInit=c(1,1,11,0.1),k=c(6e-3,1e-3,1e-5,1e-3),
sig=diag(4),Nchains=1,burnIn=3000)
###### Run the calibration
mdfit2 <- calibrate(md2,pr,opt.estim)
####### The plot generated is a list of ggplot
p <- plot(mdfit2,select.X=X[,1])
print(mdfit2)
####### Run cross validataion only (the plot function is disabled)
opt.valid <- list(type.valid='loo',nCV=10)
mdfitCV2 <- calibrate(md2,pr,opt.estim,opt.valid,onlyCV=TRUE)
print(mdfitCV2)


############### For the third model
md3 <- model(code,X,Yexp,"model3",opt.disc=list(kernel.type="gauss"))
###### Definition of the prior densities
pr <- prior(type.prior=c("gaussian","gaussian","gaussian","gaussian","gamma","gamma"),opt.prior=
list(c(1,0.01),c(1,0.01),c(11,3),c(2,0.1),c(2,0.1),c(2,0.1)))
###### Definition of the calibration options
opt.estim=list(Ngibbs=2000,Nmh=6000,thetaInit=c(1,1,11,2,0.1,0.1),k=rep(5e-3,6),sig=diag(6),Nchains=1,burnIn=3000)
###### Run the calibration
mdfit3 <- calibrate(md3,pr,opt.estim)
####### The plot generated is a list of ggplot
p <- plot(mdfit3,select.X=X[,1])
print(mdfit3)
####### Run cross validataion only (the plot function is disabled)
opt.valid <- list(type.valid='loo',nCV=10)
mdfitCV <- calibrate(md3,pr,opt.estim,opt.valid,onlyCV=TRUE)
print(mdfitCV)


############### For the fourth model
binf <- c(0.9,0.9,10.5)
bsup <- c(1.1,1.1,11.5)
opt.emul <- list(p=3,n.emul=50,type="matern5_2",binf=binf,bsup=bsup,DOE=NULL)
md4 <- model(code,X,Yexp,"model4",opt.emul,opt.disc=list(kernel.type="matern5_2"))
###### Definition of the prior densities
pr <- prior(type.prior=c("gaussian","gaussian","gaussian","gaussian","gamma","gamma"),opt.prior=
list(c(1,0.01),c(1,0.01),c(11,3),c(2,0.1),c(2,0.1),c(2,0.1)))
###### Definition of the calibration options
opt.estim=list(Ngibbs=2000,Nmh=6000,thetaInit=c(1,1,11,2,0.1,0.1),k=rep(5e-3,6),sig=diag(6),Nchains=1,burnIn=3000)
###### Run the calibration
mdfit4 <- calibrate(md4,pr,opt.estim)
####### The plot generated is a list of ggplot
p <- plot(mdfit4,select.X=X[,1])
print(mdfit4)
####### Run cross validataion only (the plot function is disabled)
opt.valid <- list(type.valid='loo',nCV=10)
mdfitCV <- calibrate(md4,pr,opt.estim,opt.valid,onlyCV=TRUE)
print(mdfitCV)

}
\seealso{
\code{\link{prior}},\code{\link{calibrate}},\code{\link{prediction}}, \code{\link{kernel.fun}}
}
\author{
M. Carmassi
}
