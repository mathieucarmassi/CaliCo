#' A Reference Class to generates differents model objects
#'
#' @include R6, FactoMineR
#' @description See the function blabla which produces an instance of this class
#'
#' This class comes with a set of methods, some of them being useful for the user:
#' See the documentation for blabla... Other methods
#'  should not be called as they are designed to be used during the optimization process.
#'
#' Fields should not be changed or manipulated by the user as they are updated internally
#' during the estimation process.
#' @field code a function which takes in entry X and theta
#' @field X the matrix of the forced variables
#' @field theta the vector of parameters to estimate
#' @field Yexp the experimental output
#' @field n the number of experiments
#' @field model the model choice see documentation
#' @seealso The function ....
model.class <- R6Class(classname = "model.class",
                 public = list(
                   code     = NULL,
                   X        = NULL,
                   Yexp     = NULL,
                   n        = NULL,
                   d        = NULL,
                   p        = NULL,
                   model    = NULL,
                   initialize = function(code=NA,X=NA,Yexp=NA,model=NA)
                   {
                     self$code  <- code
                     self$X     <- X
                     self$Yexp  <- Yexp
                     self$n     <- length(Yexp)
                     self$d     <- dim(X)[2]
                     ### Penser à donner une définition à self$p
                     self$model <- model
                     private$checkModels()
                   }
                 ))

model.class$set("private","checkModels",
        function()
        {
          if (self$model != "model1" & self$model != "model2")
          {
            stop('Please elect a correct model')
          }
        })

model1.class <- R6Class(classname = "model1.class",
                        inherit = model.class,
                        public=list(
                        initialize=function(code=NA, X=NA, Yexp=NA, model=NA)
                        {
                          super$initialize(code, X, Yexp, model)
                        },
                        fun = function(theta,sig2)
                        {
                          return(self$code(self$X,theta)+rnorm(self$n,0,sqrt(sig2)))
                        })
                        )

model2.class <- R6Class(classname = "model2.class",
                        inherit = model.class,
                        public = list(
                          n.emul = NULL,
                          GP     = NULL,
                        initialize = function(code=NA, X=NA, Yexp=NA, model=NA,n.emul=NA)
                        {
                          super$initialize(code, X, Yexp, model)
                          self$n.emul <- n.emul
                          self$GP     <- self$surrogate()
                        },
                        surrogate = function(PCA=TRUE)
                        {
                          Xcr <- scale(X)
                          V   <- attr(Xcr,"scaled:scale")
                          M   <- attr(Xcr,"scaled:center")
                          Dim <- self$p+self$d
                          if (PCA == TRUE)
                          {
                          ### PCA on the forced variables
                          PCA.test <- PCA(Xcr,graph = FALSE)
                          ### Coordinates in the new uncorrelated space of the initial points
                          B    <- PCA.test$ind$coord
                          ### Transition matrix
                          P    <- sqrt(PCA.test$var$contrib[,1:5])/10 * sign(PCA.test$var$coord[,1:5])
                          ### Establishment of the DOE
                          doe  <- lhsDesign(n.emul,4)$design
                          doe  <- maximinSA_LHS(doe)
                          doe  <- doe$design
                          ### Boundaries of the points in the new coordinates
                          binf <- apply(B,2,min)
                          bsup <- apply(B,2,max)
                          ### Unscaling the doe into the right bounds
                          DOE  <- unscale(doe[,1:3],binf[1:3],bsup[1:3])
                          ### Setting the coordinates of the two other components to 0
                          D    <- cbind(DOE,rep(0,n),rep(0,n))
                          ### Matrix containing the points from the DOE but in the initial coordinates
                          A    <- t(P%*%t(D))
                          ### Multiplication of each components by the variance and add the mean
                          for (i in 1:5)
                          {
                            A[,i] <- A[,i]*V[i]+rep(M[i],n)
                          }
                          }
                          ### Getting back the value of the parameter generated by the DOE
                          doeParam <- unscale(doe[,4],0.153,0.187)
                          ### Matrix D contains the final value for the DOE
                          D <- cbind(A,doeParam)
                          ### Generating the response
                          z <- fun2emul(D)
                          ### Converting D as a data.frame for the km function
                          D <- as.data.frame(D)
                          colnames(D) <- c("V1","V2","V3","V4","V5","V6")
                          ### Creation of the Gaussian Process with estimation of hyperpameters
                          GP <- km(formula =~V1+V2+V3+V4+V5+V6, design=D, response = z, covtype = "matern5_2")
                          return(GP)
                        },
                        fun = function(theta,sig2)
                        {
                          pr <- predict(self$GP,newdata=X,
                                        type="UK",cov.compute=TRUE)
                          err <- rnorm(n=length(pr$mean),mean = 0,sd=sqrt(theta[2]))
                        })
                        )


